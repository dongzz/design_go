# 七大设计原则
    principles
    
    -   单一职责原则
        单一职责原则，指的是一个类或者模块有只有一个改变的原因。
        
    -   开闭原则
        OCP（Open Closed Principle）
        开闭原则是设计模式中的总原则，开闭原则就是说:对拓展开放、对修改关闭。
        
        提高代码复用性
        提高代码的可维护性
    
    -   里式替换原则
        Li substitution Principle
        里式替换原则是开闭原则的实现基础，它告诉我们设计程序的时候尽可能使用基类进行对象的定义及引用，具体运行时再决定基类对应的具体子类型。
        
        里氏替换可以提高代码复用性,子类继承父类时自然继承到了父类的属性和方法。
        提高代码可拓展性，子类通过实现父类方法进行功能拓展，个性化定制。
        里氏替换中的继承有侵入性。继承，就必然拥有父类的属性和方法。
        增加了代码的耦合性。父类方法或属性的更改，要考虑子类所引发的变更。
        
    -   依赖倒置原则
        Dependence inversion principle
        要面向接口编程，不要面向实现编程。
        
        高层模块不应该依赖低层模块，都应该依赖抽象(接口或抽象类)；
        接口或抽象类不应该依赖于实现类；
        实现类应该依赖于接口或抽象类。
        
    -   接口隔离原则
        Interface Segregation Principle, ISP
        客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口， 不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少，保持接口纯洁性。
        接口尽量粒度化，保持接口纯洁性。
        接口要高内聚，即减少对外交互。
        
    -   迪米特法则
        Law of Demeter, LOD
        有时候也叫做最少知识原则(Least Knowledge Principle, LKP)，
        一个软件实体应当尽可能少地与其它实体发生相互作用。迪米特法则的初衷在于降低类之间的耦合。
        
        类定义时尽量内敛，少用 public 权限修饰符，尽量使用 private、protected。
        
    -   合成复用原则
        Synthetic reuse principle
        通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的,新对象可以调己有对象的功能，从而达到复用。原则是尽量首先使用合成/聚合的方式，而不是使用继承。
        
        类之有三种基本关系，分别是：关联(聚合和组合)、泛化(与继承同一概念)、依赖。
        聚合：学生与班级
        组合：人与器官
        
        新对象可以调用已有对象的功能，从而达到对象复用。

        各种原则要求的侧重点不同，总地来说:
        
        开闭原则是核心，对拓展开放对修改关闭是软件设计、后期拓展的基石。
        单一职责原则就要求我们设计接口，制定模块功能时保持模块或者接口功能单一，接口设计或功能设计尽量保持原子性，修改一处不能影响全局或其它模块。
        里氏替换原则和依赖倒置原则，按照笔者的理解，这俩原则总的是要求我们要面向接口、面向抽象编程，设计程序的时候尽可能使用基类或者接口进行对象的定义或引用，而不是具体的实现，否则实现一旦有变更，上层调用者就必须做出对应变更，这样一来，整个模块可能都需要重新调整，非常不利于后期拓展。
        接口隔离原则具体应用到程序中，比如我们在传统 mvc 开发时，service 层调用 dao 层一般会使用接口进行调用，各层之间尽量面向接口通信，其实也是一种降低模块耦合的方法。
        迪米特法则的初衷也是为了降低模块耦合，代码示例中我们引入了类似“中间人”的概念，上层模块不直接调用下层模块，而是引入第三方进行代办，这也是为了降低模块的耦合度。
        合成复用原则，我们介绍了聚合、组合的概念，聚合是一种弱关联，而组合是一种强关联，表现在 UML 类图上的话聚合是使用空心四边形加箭头表示，而组合是使用实心四边形加箭头表示，合成复用原则总的就是要求我们尽利用好已有对象，从而达到功能复用，具体是聚合还是组合，还是一般关联，就要看具体情况再定了。
    

# 行为型
    behavioral
    
    -   策略模式
        Strategy
        
    -   模板方法模式
        TemplateMethod
    
    -   观察者模式
        Observer
    
    -   迭代子模式
        IterativeSubpattern
    
    -   责任链模式
        ChainOfResponsibility
        
    -   命令模式
        Command
    
    -   备忘录模式
        Memo
    
    -   状态模式
        State
        
    -   访问者模式
        Visitor
        
    -   中介者模式
        Intermediary
        
    -   解释器模式
        Interpreter

# 创建型
    creational
    
    -   单例模式
        Sigleton
        
    -   简单工厂模式
        SimpleFactory
        
    -   工厂方法模式
        Factory
        
    -   抽象工厂模式
        AbstractFactory
    
    -   建造者模式
        Builder
        
    -   原型模式
        Prototype
        
# 结构型
    structural
    
    -   适配器模式
        Adapter
    
    -   装饰器模式
        Decorator
        
    -   代理模式
        Proxy
    
    -   外观模式
        Facade
    
    -   桥接模式
        Bridge
    
    -   组合模式
        Combination
        
    -   享元模式
        Flyweight
